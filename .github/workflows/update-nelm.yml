name: Update NELM Version

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      max_builds:
        description: 'Maximum number of versions to build in one run'
        required: false
        type: number
        default: 10
  pull_request:
    paths:
      - '.github/workflows/update-nelm.yml'

permissions:
  contents: write
  actions: write
  packages: read

jobs:
  discover-releases:
    runs-on: ubuntu-latest
    outputs:
      releases: ${{ steps.get-releases.outputs.result }}
    steps:
      - name: Get all stable NELM releases
        id: get-releases
        uses: actions/github-script@v8
        with:
          script: |
            const maxBuilds = parseInt(context.payload.inputs?.max_builds) || 10;

            try {
              // Get all releases from werf/nelm
              const releases = await github.rest.repos.listReleases({
                owner: 'werf',
                repo: 'nelm',
                per_page: 100
              });

              // Helper function to parse semver
              function parseSemver(version) {
                // Ensure any leading 'v' is removed
                const cleanVersion = version.replace(/^v/, '');
                const parts = cleanVersion.split('.').map(Number);
                return {
                  major: parts[0] || 0,
                  minor: parts[1] || 0,
                  patch: parts[2] || 0
                };
              }

              // Helper function to compare versions
              function compareVersions(a, b) {
                const vA = parseSemver(a);
                const vB = parseSemver(b);

                if (vA.major !== vB.major) return vB.major - vA.major;
                if (vA.minor !== vB.minor) return vB.minor - vA.minor;
                return vB.patch - vA.patch;
              }

              // Get all existing image tags from registry (once)
              async function getAllExistingTags() {
                try {
                  const packageName = context.repo.repo;
                  const allTags = new Set();
                  let page = 1;
                  const perPage = 100;

                  while (true) {
                    const response = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                      package_type: 'container',
                      package_name: packageName,
                      org: context.repo.owner,
                      per_page: perPage,
                      page: page
                    }).catch(async (orgError) => {
                      // If org call fails, try user-owned packages
                      return await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                        package_type: 'container',
                        package_name: packageName,
                        username: context.repo.owner,
                        per_page: perPage,
                        page: page
                      });
                    });

                    // Collect all tags from this page
                    response.data.forEach(pkg => {
                      const tags = pkg.metadata?.container?.tags || [];
                      tags.forEach(tag => allTags.add(tag));
                    });

                    console.log(`  Fetched page ${page}: ${response.data.length} package versions, total tags so far: ${allTags.size}`);

                    // Stop if we got less than perPage (last page)
                    if (response.data.length < perPage) break;
                    page++;

                    // Safety limit to prevent infinite loop
                    if (page > 10) {
                      console.log('  Warning: Reached page limit, there may be more versions');
                      break;
                    }
                  }

                  return allTags;
                } catch (error) {
                  console.log(`  Could not fetch existing tags: ${error.message}`);
                  return new Set(); // Return empty set on error
                }
              }

              // Filter out pre-releases (alpha, beta) and extract stable releases
              const allStableReleases = releases.data
                .filter(release => !release.prerelease)
                .map(release => {
                  const version = release.tag_name.replace(/^v/, '');

                  // Extract quality labels from release name
                  // Format: "v1.12.2 [ea,stable,rock-solid]"
                  const labelMatch = release.name.match(/\[(.*?)\]/);
                  const qualityLabels = labelMatch ? labelMatch[1] : '';

                  return {
                    version: version,
                    quality_labels: qualityLabels,
                    published_at: release.published_at
                  };
                })
                .sort((a, b) => compareVersions(a.version, b.version));

              // Group by major.minor to find latest patch version in each branch
              const minorBranches = {};
              allStableReleases.forEach(release => {
                const parsed = parseSemver(release.version);
                const minorKey = `${parsed.major}.${parsed.minor}`;
                if (!minorBranches[minorKey] || compareVersions(release.version, minorBranches[minorKey].version) < 0) {
                  minorBranches[minorKey] = release;
                }
              });

              // Mark latest in each minor branch
              Object.values(minorBranches).forEach(release => {
                release.is_latest_in_minor = true;
              });

              // Mark the latest version overall (first after sorting)
              if (allStableReleases.length > 0) {
                allStableReleases[0].is_latest = true;
              }

              // Find the newest stable/rock-solid version as a cutoff point
              const newestStable = allStableReleases.find(r =>
                r.quality_labels && (r.quality_labels.includes('stable') || r.quality_labels.includes('rock-solid'))
              );
              console.log(`Newest stable version: ${newestStable ? newestStable.version : 'none found'}`);

              // Get all existing tags from registry (once, with pagination)
              console.log('Fetching existing image tags from registry...');
              const existingTags = await getAllExistingTags();
              console.log(`Found ${existingTags.size} existing tags in registry\n`);

              // Filter out already built images and limit to maxBuilds
              console.log('Checking which releases need to be built...');
              const releasesToBuild = [];

              for (const release of allStableReleases) {
                if (releasesToBuild.length >= maxBuilds) break;

                const exists = existingTags.has(release.version);
                if (exists) {
                  console.log(`  â­ï¸  ${release.version} - already exists, skipping`);
                } else {
                  // Don't build versions older than newest stable if they don't exist
                  if (newestStable && compareVersions(release.version, newestStable.version) > 0) {
                    console.log(`  ðŸš« ${release.version} - older than stable ${newestStable.version}, skipping`);
                    continue;
                  }
                  console.log(`  âœ… ${release.version} - will build`);
                  releasesToBuild.push(release);
                }
              }

              if (releasesToBuild.length === 0) {
                console.log('No new releases to build');
                return [];
              }

              console.log(`\nWill build ${releasesToBuild.length} releases:`);
              releasesToBuild.forEach(r => {
                const latestMark = r.is_latest ? ' [LATEST - gets major tag]' : '';
                const minorMark = r.is_latest_in_minor ? ' [LATEST in minor - gets X.Y tag]' : '';
                console.log(`  - ${r.version} [${r.quality_labels || 'no labels'}]${latestMark}${minorMark}`);
              });

              return releasesToBuild;
            } catch (error) {
              core.warning(`Error getting NELM releases: ${error.message}`);
              console.log('Returning empty array due to error');
              return [];
            }
          result-encoding: json

  build-releases:
    needs: discover-releases
    if: |
      needs.discover-releases.outputs.releases != '' &&
      needs.discover-releases.outputs.releases != '[]' &&
      github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        release: ${{ fromJson(needs.discover-releases.outputs.releases) }}
      fail-fast: false
      max-parallel: 3
    steps:
      - name: Verify NELM release files are available
        id: verify-files
        run: |
          VERSION="${{ matrix.release.version }}"
          echo "Checking if NELM ${VERSION} files are available..."

          # Check both architectures
          for ARCH in amd64 arm64; do
            echo "Checking ${ARCH}..."
            NELM_URL="https://tuf.nelm.sh/targets/releases/${VERSION}/linux-${ARCH}/bin/nelm"
            SIG_URL="https://tuf.nelm.sh/targets/signatures/${VERSION}/linux-${ARCH}/bin/nelm.sig"

            # Check nelm binary
            if ! curl -fsSL --head "${NELM_URL}" > /dev/null 2>&1; then
              echo "âŒ NELM binary not available for ${ARCH}: ${NELM_URL}"
              echo "files-ready=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Check signature file
            if ! curl -fsSL --head "${SIG_URL}" > /dev/null 2>&1; then
              echo "âŒ NELM signature not available for ${ARCH}: ${SIG_URL}"
              echo "files-ready=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "âœ… Files available for ${ARCH}"
          done

          echo "âœ… All release files are available"
          echo "files-ready=true" >> $GITHUB_OUTPUT

      - name: Trigger build for NELM version
        if: steps.verify-files.outputs.files-ready == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = '${{ matrix.release.version }}';
            const qualityLabels = '${{ matrix.release.quality_labels }}';
            const isLatest = '${{ matrix.release.is_latest }}' === 'true';
            const isLatestInMinor = '${{ matrix.release.is_latest_in_minor }}' === 'true';

            console.log(`Triggering build for NELM ${version}`);
            console.log(`Quality labels: ${qualityLabels || 'none'}`);
            console.log(`Is latest overall: ${isLatest}`);
            console.log(`Is latest in minor: ${isLatestInMinor}`);

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build-and-publish.yml',
              ref: context.ref || 'main',
              inputs: {
                nelm_version: version,
                quality_labels: qualityLabels,
                is_latest: isLatest.toString(),
                is_latest_in_minor: isLatestInMinor.toString()
              }
            });

            console.log(`âœ… Build triggered for version ${version}`);

      - name: Build summary
        if: always()
        run: |
          echo "## Build Request Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${{ matrix.release.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Quality Labels: ${{ matrix.release.quality_labels || 'none' }}" >> $GITHUB_STEP_SUMMARY
          echo "- Files Available: ${{ steps.verify-files.outputs.files-ready }}" >> $GITHUB_STEP_SUMMARY
